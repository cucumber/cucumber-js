## API Report File for "@cucumber/cucumber"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { EventEmitter } from 'node:events';
import { Expression } from '@cucumber/cucumber-expressions';
import { GeneratedExpression } from '@cucumber/cucumber-expressions';
import { IDefineStep as IDefineStep_2 } from './support_code_library_builder/types';
import { IDefineTestCaseHookOptions as IDefineTestCaseHookOptions_2 } from './support_code_library_builder/types';
import { IDefineTestRunHookOptions as IDefineTestRunHookOptions_2 } from './support_code_library_builder/types';
import { IDefineTestStepHookOptions as IDefineTestStepHookOptions_2 } from './support_code_library_builder/types';
import { IdGenerator } from '@cucumber/messages';
import { IParameterTypeDefinition as IParameterTypeDefinition_2 } from './support_code_library_builder/types';
import { IWorld as IWorld_2 } from './support_code_library_builder/world';
import { JsonObject } from 'type-fest';
import * as messages from '@cucumber/messages';
import { ParallelAssignmentValidator as ParallelAssignmentValidator_2 } from './support_code_library_builder/types';
import { ParameterType } from '@cucumber/cucumber-expressions';
import { ParameterTypeRegistry } from '@cucumber/cucumber-expressions';
import { Readable } from 'node:stream';
import { TestCaseHookFunction as TestCaseHookFunction_2 } from './support_code_library_builder/types';
import { TestRunHookFunction as TestRunHookFunction_2 } from './support_code_library_builder/types';
import { TestStepHookFunction as TestStepHookFunction_2 } from './support_code_library_builder/types';
import { TestStepResultStatus } from '@cucumber/messages';
import { Writable } from 'node:stream';

// @public (undocumented)
export const After: (<WorldType = IWorld_2<any>>(code: TestCaseHookFunction_2<WorldType>) => void) & (<WorldType_1 = IWorld_2<any>>(tags: string, code: TestCaseHookFunction_2<WorldType_1>) => void) & (<WorldType_2 = IWorld_2<any>>(options: IDefineTestCaseHookOptions_2, code: TestCaseHookFunction_2<WorldType_2>) => void);

// @public (undocumented)
export const AfterAll: ((code: TestRunHookFunction_2) => void) & ((options: IDefineTestRunHookOptions_2, code: TestRunHookFunction_2) => void);

// @public (undocumented)
export const AfterStep: (<WorldType = IWorld_2<any>>(code: TestStepHookFunction_2<WorldType>) => void) & (<WorldType_1 = IWorld_2<any>>(tags: string, code: TestStepHookFunction_2<WorldType_1>) => void) & (<WorldType_2 = IWorld_2<any>>(options: IDefineTestStepHookOptions_2, code: TestStepHookFunction_2<WorldType_2>) => void);

// @public (undocumented)
function atMostOnePicklePerTag(tagNames: string[]): ParallelAssignmentValidator;

// @public (undocumented)
export const Before: (<WorldType = IWorld_2<any>>(code: TestCaseHookFunction_2<WorldType>) => void) & (<WorldType_1 = IWorld_2<any>>(tags: string, code: TestCaseHookFunction_2<WorldType_1>) => void) & (<WorldType_2 = IWorld_2<any>>(options: IDefineTestCaseHookOptions_2, code: TestCaseHookFunction_2<WorldType_2>) => void);

// @public (undocumented)
export const BeforeAll: ((code: TestRunHookFunction_2) => void) & ((options: IDefineTestRunHookOptions_2, code: TestRunHookFunction_2) => void);

// @public (undocumented)
export const BeforeStep: (<WorldType = IWorld_2<any>>(code: TestStepHookFunction_2<WorldType>) => void) & (<WorldType_1 = IWorld_2<any>>(tags: string, code: TestStepHookFunction_2<WorldType_1>) => void) & (<WorldType_2 = IWorld_2<any>>(options: IDefineTestStepHookOptions_2, code: TestStepHookFunction_2<WorldType_2>) => void);

// @public @deprecated (undocumented)
export const Cli: typeof Cli_2;

// @beta
const context_2: IContext<any>;
export { context_2 as context }

// @public (undocumented)
export class DataTable {
    constructor(sourceTable: messages.PickleTable | string[][]);
    // (undocumented)
    hashes(): Record<string, string>[];
    // (undocumented)
    raw(): string[][];
    // (undocumented)
    rows(): string[][];
    // (undocumented)
    rowsHash(): Record<string, string>;
    // (undocumented)
    transpose(): DataTable;
}

// @public (undocumented)
export const defineParameterType: (options: IParameterTypeDefinition_2<any>) => void;

// @public (undocumented)
export const defineStep: IDefineStep_2;

// @public (undocumented)
class EventDataCollector {
    constructor(eventBroadcaster: EventEmitter);
    // (undocumented)
    getGherkinDocument(uri: string): messages.GherkinDocument;
    // (undocumented)
    getPickle(pickleId: string): messages.Pickle;
    // (undocumented)
    getTestCaseAttempt(testCaseStartedId: string): ITestCaseAttempt;
    // (undocumented)
    getTestCaseAttempts(): ITestCaseAttempt[];
    // (undocumented)
    parseEnvelope(envelope: messages.Envelope): void;
    // (undocumented)
    storeAttachment(attachment: messages.Attachment): void;
    // (undocumented)
    storeTestCaseResult({ testCaseStartedId, willBeRetried, }: messages.TestCaseFinished): void;
    // (undocumented)
    storeTestStepResult({ testCaseStartedId, testStepId, testStepResult, }: messages.TestStepFinished): void;
    // (undocumented)
    readonly undefinedParameterTypes: messages.UndefinedParameterType[];
}

// @public (undocumented)
function formatIssue({ colorFns, number, snippetBuilder, testCaseAttempt, supportCodeLibrary, printAttachments, }: IFormatIssueRequest): string;

// @public (undocumented)
function formatLocation(obj: ILineAndUri, cwd?: string): string;

// @public (undocumented)
function formatSummary({ colorFns, testCaseAttempts, testRunDuration, }: IFormatSummaryRequest): string;

// @public (undocumented)
export class Formatter {
    constructor(options: IFormatterOptions);
    // (undocumented)
    protected colorFns: IColorFns;
    // (undocumented)
    protected cwd: string;
    // (undocumented)
    static readonly documentation: string;
    // (undocumented)
    protected eventDataCollector: EventDataCollector;
    // (undocumented)
    finished(): Promise<void>;
    // (undocumented)
    protected log: IFormatterLogFn;
    // (undocumented)
    protected printAttachments: boolean;
    // (undocumented)
    protected snippetBuilder: StepDefinitionSnippetBuilder;
    // (undocumented)
    protected stream: Writable;
    // (undocumented)
    protected supportCodeLibrary: SupportCodeLibrary;
}

// @public (undocumented)
export const FormatterBuilder: {
    build(FormatterConstructor: string | typeof Formatter, options: IBuildOptions): Promise<Formatter>;
    getConstructorByType(type: string, cwd: string): Promise<typeof Formatter>;
    getStepDefinitionSnippetBuilder({ cwd, snippetInterface, snippetSyntax, supportCodeLibrary, }: IGetStepDefinitionSnippetBuilderOptions): Promise<StepDefinitionSnippetBuilder>;
    loadCustomClass(type: 'formatter' | 'syntax', descriptor: string, cwd: string): Promise<any>;
    loadFile(urlOrName: URL | string): Promise<any>;
    resolveConstructor(ImportedCode: any): any;
};

declare namespace formatterHelpers {
    export {
        parseTestCaseAttempt,
        EventDataCollector,
        KeywordType,
        getStepKeywordType,
        formatIssue,
        isWarning,
        isFailure,
        isIssue,
        formatLocation,
        formatSummary,
        getUsage,
        GherkinDocumentParser,
        PickleParser
    }
}
export { formatterHelpers }

// @public (undocumented)
function getGherkinExampleRuleMap(gherkinDocument: messages.GherkinDocument): Record<string, messages.Rule>;

// @public (undocumented)
function getGherkinScenarioLocationMap(gherkinDocument: messages.GherkinDocument): Record<string, messages.Location>;

// @public (undocumented)
function getGherkinScenarioMap(gherkinDocument: messages.GherkinDocument): Record<string, messages.Scenario>;

// @public (undocumented)
function getGherkinStepMap(gherkinDocument: messages.GherkinDocument): Record<string, messages.Step>;

// @public (undocumented)
function getPickleLocation({ gherkinDocument, pickle, }: IGetPickleLocationRequest): messages.Location;

// @public (undocumented)
function getPickleStepMap(pickle: messages.Pickle): Record<string, messages.PickleStep>;

// @public (undocumented)
function getScenarioDescription({ pickle, gherkinScenarioMap, }: IGetScenarioDescriptionRequest): string;

// @public (undocumented)
function getStepKeyword({ pickleStep, gherkinStepMap, }: IGetStepKeywordRequest): string;

// @public (undocumented)
function getStepKeywordType({ keyword, language, previousKeywordType, }: IGetStepKeywordTypeOptions): KeywordType;

// @public (undocumented)
function getUsage({ stepDefinitions, eventDataCollector, }: IGetUsageRequest): IUsage[];

declare namespace GherkinDocumentParser {
    export {
        getGherkinStepMap,
        getGherkinScenarioMap,
        getGherkinExampleRuleMap,
        getGherkinScenarioLocationMap
    }
}

// @public (undocumented)
export const Given: IDefineStep_2;

// @public (undocumented)
export interface IContext<ParametersType = any> {
    // (undocumented)
    readonly parameters: ParametersType;
}

// @public (undocumented)
export interface IFormatterOptions {
    // (undocumented)
    cleanup: IFormatterCleanupFn;
    // (undocumented)
    colorFns: IColorFns;
    // (undocumented)
    cwd: string;
    // (undocumented)
    eventBroadcaster: EventEmitter;
    // (undocumented)
    eventDataCollector: EventDataCollector;
    // (undocumented)
    log: IFormatterLogFn;
    // (undocumented)
    parsedArgvOptions: FormatOptions;
    // (undocumented)
    snippetBuilder: StepDefinitionSnippetBuilder;
    // (undocumented)
    stream: Writable;
    // (undocumented)
    supportCodeLibrary: SupportCodeLibrary;
}

// @public (undocumented)
interface IGetPickleLocationRequest {
    // (undocumented)
    gherkinDocument: messages.GherkinDocument;
    // (undocumented)
    pickle: messages.Pickle;
}

// @public (undocumented)
interface IGetScenarioDescriptionRequest {
    // (undocumented)
    gherkinScenarioMap: Record<string, messages.Scenario>;
    // (undocumented)
    pickle: messages.Pickle;
}

// @public (undocumented)
interface IGetStepKeywordRequest {
    // (undocumented)
    gherkinStepMap: Record<string, messages.Step>;
    // (undocumented)
    pickleStep: messages.PickleStep;
}

// @public (undocumented)
export interface INewRuntimeOptions {
    // (undocumented)
    eventBroadcaster: EventEmitter;
    // (undocumented)
    eventDataCollector: EventDataCollector;
    // (undocumented)
    newId: IdGenerator.NewId;
    // (undocumented)
    options: IRuntimeOptions;
    // (undocumented)
    pickleIds: string[];
    // (undocumented)
    supportCodeLibrary: SupportCodeLibrary;
}

// @public (undocumented)
export interface IRuntimeOptions {
    // (undocumented)
    dryRun: boolean;
    // (undocumented)
    failFast: boolean;
    // (undocumented)
    filterStacktraces: boolean;
    // (undocumented)
    retry: number;
    // (undocumented)
    retryTagFilter: string;
    // (undocumented)
    strict: boolean;
    // (undocumented)
    worldParameters: JsonObject;
}

// @public (undocumented)
function isFailure(result: messages.TestStepResult, willBeRetried?: boolean): boolean;

// @public (undocumented)
function isIssue(result: messages.TestStepResult): boolean;

// @public (undocumented)
function isWarning(result: messages.TestStepResult, willBeRetried?: boolean): boolean;

// @public (undocumented)
export interface ITestCaseHookParameter {
    // (undocumented)
    gherkinDocument: messages.GherkinDocument;
    // (undocumented)
    pickle: messages.Pickle;
    // (undocumented)
    result?: messages.TestStepResult;
    // (undocumented)
    testCaseStartedId: string;
    // (undocumented)
    willBeRetried?: boolean;
}

// @public (undocumented)
export interface ITestStepHookParameter {
    // (undocumented)
    gherkinDocument: messages.GherkinDocument;
    // (undocumented)
    pickle: messages.Pickle;
    // (undocumented)
    pickleStep: messages.PickleStep;
    // (undocumented)
    result: messages.TestStepResult;
    // (undocumented)
    testCaseStartedId: string;
    // (undocumented)
    testStepId: string;
}

// @public (undocumented)
export interface IWorld<ParametersType = any> {
    // (undocumented)
    [key: string]: any;
    // (undocumented)
    readonly attach: ICreateAttachment;
    // (undocumented)
    readonly log: ICreateLog;
    // (undocumented)
    readonly parameters: ParametersType;
}

// @public (undocumented)
export interface IWorldOptions<ParametersType = any> {
    // (undocumented)
    attach: ICreateAttachment;
    // (undocumented)
    log: ICreateLog;
    // (undocumented)
    parameters: ParametersType;
}

// @public (undocumented)
export class JsonFormatter extends Formatter {
    constructor(options: IFormatterOptions);
    // (undocumented)
    convertNameToId(obj: messages.Feature | messages.Pickle): string;
    // (undocumented)
    static readonly documentation: string;
    // (undocumented)
    formatDataTable(dataTable: messages.PickleTable): any;
    // (undocumented)
    formatDocString(docString: messages.PickleDocString, gherkinStep: messages.Step): any;
    // (undocumented)
    formatStepArgument(stepArgument: messages.PickleStepArgument, gherkinStep: messages.Step): any;
    // (undocumented)
    getFeatureData({ feature, elements, uri, }: IBuildJsonFeatureOptions): IJsonFeature;
    // (undocumented)
    getFeatureTags(feature: messages.Feature): IJsonTag[];
    // (undocumented)
    getScenarioData({ feature, gherkinScenarioLocationMap, gherkinExampleRuleMap, gherkinScenarioMap, pickle, steps, }: IBuildJsonScenarioOptions): IJsonScenario;
    // (undocumented)
    getScenarioTags({ feature, pickle, gherkinScenarioMap, }: {
        feature: messages.Feature;
        pickle: messages.Pickle;
        gherkinScenarioMap: Record<string, messages.Scenario>;
    }): IJsonTag[];
    // (undocumented)
    getStepData({ isBeforeHook, gherkinStepMap, pickleStepMap, testStep, testStepAttachments, testStepResult, }: IBuildJsonStepOptions): IJsonStep;
    // (undocumented)
    onTestRunFinished(): void;
}

// @public (undocumented)
enum KeywordType {
    // (undocumented)
    Event = "event",
    // (undocumented)
    Outcome = "outcome",
    // (undocumented)
    Precondition = "precondition"
}

declare namespace parallelCanAssignHelpers {
    export {
        atMostOnePicklePerTag
    }
}
export { parallelCanAssignHelpers }

// @public @deprecated (undocumented)
export const parseGherkinMessageStream: typeof cliHelpers.parseGherkinMessageStream;

// @public (undocumented)
function parseTestCaseAttempt({ testCaseAttempt, snippetBuilder, supportCodeLibrary, }: IParseTestCaseAttemptRequest): IParsedTestCaseAttempt;

// @public @deprecated (undocumented)
export const PickleFilter: typeof PickleFilter_2;

declare namespace PickleParser {
    export {
        getScenarioDescription,
        getStepKeyword,
        getPickleStepMap,
        getPickleLocation,
        IGetPickleLocationRequest,
        IGetStepKeywordRequest,
        IGetScenarioDescriptionRequest
    }
}

// @public (undocumented)
export class ProgressFormatter extends SummaryFormatter {
    constructor(options: IFormatterOptions);
    // (undocumented)
    static readonly documentation: string;
    // (undocumented)
    logProgress({ testStepResult: { status } }: TestStepFinished): void;
}

// @public (undocumented)
export class RerunFormatter extends Formatter {
    constructor(options: IFormatterOptions);
    // (undocumented)
    static readonly documentation: string;
    // (undocumented)
    formatFailedTestCases(): string;
    // (undocumented)
    getFailureMap(): UriToLinesMap;
    // (undocumented)
    logFailedTestCases(): void;
    // (undocumented)
    protected readonly separator: string;
}

// @public @deprecated (undocumented)
export const Runtime: typeof Runtime_2;

// @public (undocumented)
export const setDefaultTimeout: (milliseconds: number) => void;

// @public (undocumented)
export const setDefinitionFunctionWrapper: (fn: Function) => void;

// @public (undocumented)
export const setParallelCanAssign: (fn: ParallelAssignmentValidator_2) => void;

// @public (undocumented)
export const setWorldConstructor: (fn: any) => void;

// @public (undocumented)
export class SnippetsFormatter extends Formatter {
    constructor(options: IFormatterOptions);
    // (undocumented)
    static readonly documentation: string;
    // (undocumented)
    logSnippets(): void;
}

// @public (undocumented)
export const Status: typeof messages.TestStepResultStatus;

// @public (undocumented)
export class SummaryFormatter extends Formatter {
    constructor(options: IFormatterOptions);
    // (undocumented)
    static readonly documentation: string;
    // (undocumented)
    logIssues({ issues, title }: ILogIssuesRequest): void;
    // (undocumented)
    logSummary(testRunDuration: messages.Duration): void;
}

// @public (undocumented)
export const supportCodeLibraryBuilder: SupportCodeLibraryBuilder;

// @public (undocumented)
export class TestCaseHookDefinition extends Definition implements IDefinition {
    constructor(data: IDefinitionParameters<IHookDefinitionOptions>);
    // (undocumented)
    appliesToTestCase(pickle: messages.Pickle): boolean;
    // (undocumented)
    getInvocationParameters({ hookParameter, }: IGetInvocationDataRequest): Promise<IGetInvocationDataResponse>;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly tagExpression: string;
}

// @public (undocumented)
export const Then: IDefineStep_2;

// @public (undocumented)
export class UsageFormatter extends Formatter {
    constructor(options: IFormatterOptions);
    // (undocumented)
    static readonly documentation: string;
    // (undocumented)
    logUsage(): void;
}

// @public (undocumented)
export class UsageJsonFormatter extends Formatter {
    constructor(options: IFormatterOptions);
    // (undocumented)
    static readonly documentation: string;
    // (undocumented)
    logUsage(): void;
    // (undocumented)
    replacer(key: string, value: any): any;
}

// @public (undocumented)
export const version: string;

// @public (undocumented)
export const When: IDefineStep_2;

// @public (undocumented)
export class World<ParametersType = any> implements IWorld<ParametersType> {
    constructor({ attach, log, parameters }: IWorldOptions<ParametersType>);
    // (undocumented)
    readonly attach: ICreateAttachment;
    // (undocumented)
    readonly log: ICreateLog;
    // (undocumented)
    readonly parameters: ParametersType;
}

// @beta
export const world: IWorld<any>;

// @public (undocumented)
export function wrapPromiseWithTimeout<T>(promise: Promise<T>, timeoutInMilliseconds: number, timeoutMessage?: string): Promise<T>;

```
