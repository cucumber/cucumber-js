## API Report File for "@cucumber/cucumber"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Envelope } from '@cucumber/messages';
import { GherkinDocument } from '@cucumber/messages';
import { JsonObject } from 'type-fest';
import { Location } from '@cucumber/messages';
import { Pickle } from '@cucumber/messages';
import { Writable } from 'node:stream';

// @public
export type CoordinatorContext<OptionsType> = {
    operation: PluginOperation;
    on: <EventKey extends CoordinatorEventKey>(event: EventKey, handler: CoordinatorEventHandler<EventKey>) => void;
    transform: <EventKey extends CoordinatorTransformKey>(event: EventKey, handler: CoordinatorTransformer<EventKey>) => void;
    options: OptionsType;
    logger: ILogger;
    environment: CoordinatorEnvironment;
};

// @public
export type CoordinatorEnvironment = {
    cwd: string;
    stderr: Writable;
    env: Record<string, string | undefined>;
};

// @public
export type CoordinatorEventHandler<K extends CoordinatorEventKey> = (value: CoordinatorEventValues[K]) => void;

// @public
export type CoordinatorEventKey = 'message' | 'paths:resolve';

// @public
export type CoordinatorEventValues = {
    message: Readonly<Envelope>;
    'paths:resolve': Readonly<IResolvedPaths>;
};

// @public
export type CoordinatorTransformer<K extends CoordinatorTransformKey> = (value: CoordinatorTransformValues[K]) => PromiseLike<CoordinatorTransformValues[K]> | CoordinatorTransformValues[K];

// @public
export type CoordinatorTransformKey = 'pickles:filter' | 'pickles:order';

// @public
export type CoordinatorTransformValues = {
    'pickles:filter': Readonly<Array<IFilterablePickle>>;
    'pickles:order': Readonly<Array<IFilterablePickle>>;
};

// @public
export interface IConfiguration {
    backtrace: boolean;
    dryRun: boolean;
    failFast: boolean;
    forceExit: boolean;
    format: Array<string | [string, string?]>;
    formatOptions: JsonObject;
    import: string[];
    language: string;
    loader: string[];
    name: string[];
    order: IPickleOrder;
    parallel: number;
    paths: string[];
    plugin: string[];
    pluginOptions: JsonObject;
    publish: boolean;
    require: string[];
    requireModule: string[];
    retry: number;
    retryTagFilter: string;
    shard: string;
    strict: boolean;
    tags: string;
    worldParameters: JsonObject;
}

// @public
export interface IFilterablePickle {
    // (undocumented)
    gherkinDocument: GherkinDocument;
    // (undocumented)
    location: Location;
    // (undocumented)
    pickle: Pickle;
}

// @public
export interface ILoadConfigurationOptions {
    file?: string | false;
    profiles?: string[];
    provided?: Partial<IConfiguration> | string[] | string;
}

// @public
export interface ILoadSourcesResult {
    errors: ISourcesError[];
    plan: IPlannedPickle[];
}

// @public
export interface ILoadSupportOptions {
    // (undocumented)
    sources: ISourcesCoordinates;
    // (undocumented)
    support: Partial<ISupportCodeCoordinates>;
}

// @public
export interface ILogger {
    // (undocumented)
    debug: (message?: any, ...optionalParams: any[]) => void;
    // (undocumented)
    error: (message?: any, ...optionalParams: any[]) => void;
    // (undocumented)
    info: (message?: any, ...optionalParams: any[]) => void;
    // (undocumented)
    warn: (message?: any, ...optionalParams: any[]) => void;
}

// @public
export type IPickleOrder = 'defined' | 'reverse' | 'random' | `random:${string}`;

// @public
export interface IPlannedPickle {
    // (undocumented)
    location: {
        line: number;
        column?: number;
    };
    name: string;
    // (undocumented)
    uri: string;
}

// @public
export interface IPublishConfig {
    token: string;
    url: string;
}

// @public
export interface IResolvedConfiguration {
    runConfiguration: IRunConfiguration;
    useConfiguration: IConfiguration;
}

// @public
export interface IResolvedPaths {
    // (undocumented)
    importPaths: string[];
    // (undocumented)
    requirePaths: string[];
    // (undocumented)
    sourcePaths: string[];
    // (undocumented)
    unexpandedSourcePaths: string[];
}

// @public
export interface IRunConfiguration {
    // (undocumented)
    formats: IRunOptionsFormats;
    // (undocumented)
    plugins: IRunOptionsPlugins;
    // (undocumented)
    runtime: IRunOptionsRuntime;
    // (undocumented)
    sources: ISourcesCoordinates;
    // (undocumented)
    support: Partial<ISupportCodeCoordinates>;
}

// @public
export interface IRunEnvironment {
    cwd?: string;
    debug?: boolean;
    env?: Record<string, string | undefined>;
    stderr?: Writable;
    stdout?: Writable;
}

// @public
export interface IRunOptions {
    // (undocumented)
    formats: IRunOptionsFormats;
    // (undocumented)
    plugins: IRunOptionsPlugins;
    // (undocumented)
    runtime: IRunOptionsRuntime;
    // (undocumented)
    sources: ISourcesCoordinates;
    // (undocumented)
    support: ISupportCodeCoordinatesOrLibrary;
}

// @public
export interface IRunOptionsFormats {
    files: Record<string, string>;
    options: JsonObject;
    publish: IPublishConfig | false;
    stdout: string;
}

// @public
export interface IRunOptionsPlugins {
    options: JsonObject;
    specifiers: string[];
}

// @public
export interface IRunOptionsRuntime {
    dryRun: boolean;
    failFast: boolean;
    filterStacktraces: boolean;
    parallel: number;
    retry: number;
    retryTagFilter: string;
    strict: boolean;
    worldParameters: JsonObject;
}

// @public
export interface IRunResult {
    success: boolean;
    support: ISupportCodeLibrary;
}

// @public
export interface ISourcesCoordinates {
    defaultDialect: string;
    names: string[];
    order: IPickleOrder;
    paths: string[];
    shard?: string;
    tagExpression: string;
}

// @public
export interface ISourcesError {
    // (undocumented)
    location: {
        line: number;
        column?: number;
    };
    message: string;
    // (undocumented)
    uri: string;
}

// @public
export interface ISupportCodeCoordinates {
    importPaths: string[];
    loaders: string[];
    requireModules: string[];
    requirePaths: string[];
}

// @public
export type ISupportCodeCoordinatesOrLibrary = Partial<ISupportCodeCoordinates> | ISupportCodeLibrary;

// @public
export interface ISupportCodeLibrary {
    // (undocumented)
    readonly originalCoordinates: ISupportCodeCoordinates;
}

// @public
export function loadConfiguration(options?: ILoadConfigurationOptions, environment?: IRunEnvironment): Promise<IResolvedConfiguration>;

// @public
export function loadSources(coordinates: ISourcesCoordinates, environment?: IRunEnvironment): Promise<ILoadSourcesResult>;

// @public
export function loadSupport(options: ILoadSupportOptions, environment?: IRunEnvironment): Promise<ISupportCodeLibrary>;

// @public
export type Plugin<OptionsType = any> = {
    type: 'plugin';
    coordinator: (context: CoordinatorContext<OptionsType>) => PromiseLike<PluginCleanup | void> | PluginCleanup | void;
    optionsKey?: string;
};

// @public
export type PluginCleanup = () => PromiseLike<void> | void;

// @public
export type PluginOperation = 'loadSources' | 'loadSupport' | 'runCucumber';

// @public
export function runCucumber(options: IRunOptions, environment?: IRunEnvironment, onMessage?: (message: Envelope) => void): Promise<IRunResult>;

```
